import model.MergeSort;

import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;

public class Week1 {
    public static void main(String[] args) {
        new Week1().run();
    }

    public void run(){
//        Opdracht1.Opdracht1();
//        Opdracht2.Opdracht2();
//        Opdracht3.Opdracht3();
        Opdracht4.Opdracht4();
    }













//    De vorige opdracht was een typisch voorbeeld van een divide-and-conquer strategie om een probleem
//    op te lossen. Java heeft een speciaal framework om dit soort oplossingen te implementeren:
//    RecursiveTask in combinatie met een ForkJoin-threadpool.
//    Maak een versie van je programma waarbij je niet zelf de threads maakt (zoals in opdracht 1.4), maar
//    een ForkJoin threadpool gebruikt, samen met de RecursiveTask.
//    Bepaal nu weer hoe lang je programma nodig heeft om te sorteren. Hoe vergelijken de tijden met die
//    van opdracht 1.4? Hoeveel threads denk je dat gebruikt worden door de ForkJoin-pool (leg uit waarom
//            je dat denkt)?
    private void Opdracht5() {

    }








}
